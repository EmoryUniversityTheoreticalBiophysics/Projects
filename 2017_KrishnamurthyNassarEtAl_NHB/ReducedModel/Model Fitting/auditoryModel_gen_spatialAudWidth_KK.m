function [negLLik, input] = auditoryModel_gen_spatialAudWidth_KK(input)


% % ** IMPORTANT ** --- this version does not fit auditory noise width.

% this function can fit a flexible inference/perception model to
% prediction and perception data from the auditory change-point task.

% input is a structure containing the following fields:
% params

% 1) hazard rate
% 2) motor std

% genDataFlag = if true, model will generate data from a set of params,
%               otherwise it will infer the log likelihood of input.prediction &
%               input.perception.

%NOTE: when genDataFlag is set to TRUE, any arrays passed in
%input.prediction and input.perception will be overwritten



% These variables are arrays with one element for each trial:
% blockNum    = integer describing the block number for each sound.
% blockStd    = standard deviation associated with each block.
% prediction  = subject prediction ([0 180]) -- send nans if genDataFlag
% perception  = subject perception ([0 180]) -- send nans if genDataFlag

% these variables are arrays with one element for each sound:

% probeTrial  = logical array identifying which trials were probe trials
% trialNum    = integer array attributing sounds to trials.
% outcome     = auditory outcome and location.
% soundBlock  = integer array attributing sounds to blocks.



nProbes = sum(input.probeTrial);



% input.prediction = prediction data generated by model;
% input.perception = perception data generated by model;
% logLikelihood = log likelihood of generated data;


%calculate the model predictions for the given params
hazard = input.params(1);
motorStd = input.params(2);
audLikeWid = input.audWidth;  %3 different auditory likelihood widths for each subject

% fix these for now, but in the future we could turn them into parameters:
driftParam = 0;
likeWt = 1;
initGuess = 90;
inRun=.0001;

respStd=nan(size(input.blockNum));
respMu=nan(size(input.blockNum));
predPriorStd = nan(size(input.blockNum));
blkModelPredSigma=nan(size(input.blockNum));
for i = 1:max(input.blockNum)
    sel=input.blockNum==i;
    soundSel=input.soundBlock==i;
    % for now we'll fix noise to a reasonable value:
    sessNoise=unique(input.blockStd(sel));
    
    
    % for now we'll run over all outcomes with the model without resetting
    % uncertainty after each probe trial... probably should reset
    % uncertainty, but this is faster.
    
    [belief, totSig, RU, pChange] = frugFun5_wRange(input.outcome(soundSel), hazard,...
        sessNoise, driftParam, likeWt, 0, initGuess, inRun, [0, 180])  ;
    
    % get predictive mean and sigma over outcomes for probe trials:
    allMu = belief(1:end-1);
   
    
    blkModelPredMu = allMu(input.probeTrial(soundSel));  %predictive mean
    blkModelPredSigma(sel) = totSig(input.probeTrial(soundSel));       %predictive std
    %blkModelPredSigma(sel) = totSig(input.probeTrial(soundSel));
    
    % get total sigma over prediction (includes motor noise):
    
    if input.samplePrior==true
        respStd(sel) = (blkModelPredSigma(sel).^2 + motorStd.^2).^0.5;
    else
        respStd(sel) = motorStd;   %in this case we pick the exact posterior Mu
    end
    
    
    respMu(sel) = blkModelPredMu; %+ motorBias.*(90 - blkModelPredMu);
    
    %predPriorStd(sel) = 
    
    
    minTnum=find(sel,1);
    
    % IF THE genDataFlag is up, simulate data to replace prediction and
    % perception vectors:
    gridTicks = 0:180;
    if input.genDataFlag
        allK=find(sel);
        for ind=1:length(allK);
            k = allK(ind);
            
            selSound=input.trialNum==k & input.probeTrial; % get probe sound for trial
            % generate prediction:
            %while ~isfinite(input.prediction(k)) || input.prediction(k)>180 || input.prediction(k)<0
            %    input.prediction(k)=normrnd(respMu(k), respStd(k));
            %end
            
            input.prediction(k)= respMu(k);
            
            % generate internal representation:
            internalLike=-300;
            
            while (internalLike > 180 || internalLike < 0)
                internalLike = normrnd(input.outcome(selSound), audLikeWid(selSound));
            end
            

           [postDist,CPP] = ...
                combinePriorAndAllLikes_KK(input.prediction(k), blkModelPredSigma(k),...
                        internalLike, audLikeWid(selSound), hazard);
                    
            outcomeDist = postDist/sum(postDist);
        
            input.perception(k) =  sum(gridTicks.*outcomeDist);
            input.CPP(k) = CPP;
        end
    end
end



% Now let us calculate the posterior distribution after the
% model has access to the noisy sensory stimulus. If the
% internal representation distr. is very different from the
% predictive distribution, then the prior is discarded.

% You only need to calculate this for wager trials
% (fixated)


% Internal representation means
% p(internal response|data)
% on each trial the unreliable sensory information should produce a
% likelihood distribution (with a mean drawn from the likelihood distribution)
% and a variance equal to that of the likelihood.

negLLik = Inf;

if nargout>1
    input.trialOutcome=input.outcome(input.probeTrial)';
    input.totUnc=blkModelPredSigma;
    
end


