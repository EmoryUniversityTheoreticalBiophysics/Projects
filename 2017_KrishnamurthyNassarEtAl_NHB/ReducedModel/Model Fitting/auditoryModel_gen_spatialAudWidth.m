function [negLLik, input] = auditoryModel_gen_spatialAudWidth(input)


% Updated 7/28/16 by MRN to incorporate "prediction noise" that corrupts
% predictions with respect to the fixed frugal model (and increases
% prediction uncertainty). 



if ~isfield(input, 'predictionStd')
    input.predictionStd=0;
end



% % ** IMPORTANT ** --- this version does not fit auditory noise width.

% this function can fit a flexible inference/perception model to
% prediction and perception data from the auditory change-point task. 

% input is a structure containing the following fields:
% params

        % 1) hazard rate
        % 2) motor std

% genDataFlag = if true, model will generate data from a set of params,
%               otherwise it will infer the log likelihood of input.prediction &
%               input.perception.

%NOTE: when genDataFlag is set to TRUE, any arrays passed in
%input.prediction and input.perception will be overwritten



% These variables are arrays with one element for each trial:
% blockNum    = integer describing the block number for each sound. 
% blockStd    = standard deviation associated with each block.
% prediction  = subject prediction ([0 180]) -- send nans if genDataFlag
% perception  = subject perception ([0 180]) -- send nans if genDataFlag

% these variables are arrays with one element for each sound:

% probeTrial  = logical array identifying which trials were probe trials
% trialNum    = integer array attributing sounds to trials.
% outcome     = auditory outcome and location. 
% soundBlock  = integer array attributing sounds to blocks.



nProbes = sum(input.probeTrial);



% input.prediction = prediction data generated by model;
% input.perception = perception data generated by model;
% logLikelihood = log likelihood of generated data;
        
        
%calculate the model predictions for the given params
hazard = input.params(1);
motorStd = input.params(2);
audLikeWid = input.audWidth;  %3 different auditory likelihood widths for each subject

% fix these for now, but in the future we could turn them into parameters:
driftParam = 0;
likeWt = 1;
initGuess = 90;
inRun=.0001;

respStd=nan(size(input.blockNum));
respMu=nan(size(input.blockNum));
blkModelPredSigma=nan(size(input.blockNum));
for i = 1:max(input.blockNum)
    sel=input.blockNum==i;
    soundSel=input.soundBlock==i;
    % for now we'll fix noise to a reasonable value:
    sessNoise=unique(input.blockStd(sel)); 
   
    
    % for now we'll run over all outcomes with the model without resetting
    % uncertainty after each probe trial... probably should reset
    % uncertainty, but this is faster.
    
    [belief, totSig, RU, pChange] = frugFun5_wRange(input.outcome(soundSel), hazard,...
        sessNoise, driftParam, likeWt, 0, initGuess, inRun, [0, 180])  ;
    
    % get predictive mean and sigma over outcomes for probe trials:
    allMu = belief(1:end-1); 
    blkModelPredMu = allMu(input.probeTrial(soundSel));  %predictive mean
    blkModelPredSigma(sel) = totSig(input.probeTrial(soundSel));       %predictive std
    
    % get total sigma over prediction (includes motor noise):
    
    if input.samplePrior==true
    respStd(sel) = (blkModelPredSigma(sel).^2 + motorStd.^2).^0.5;
    else
    respStd(sel) = motorStd;   %in this case we pick the exact posterior Mu
    end
    
    
    respMu(sel) = blkModelPredMu; %+ motorBias.*(90 - blkModelPredMu);
    
    
    minTnum=find(sel,1);
    
    % IF THE genDataFlag is up, simulate data to replace prediction and
    % perception vectors:
    
    if input.genDataFlag
        allK=find(sel);
        for ind=1:length(allK);
            k = allK(ind);
   
            selSound=input.trialNum==k & input.probeTrial; % get probe sound for trial
            % generate prediction:
            while ~isfinite(input.prediction(k))| input.prediction(k)>180| input.prediction(k)<0
            input.prediction(k)=normrnd(respMu(k),  sqrt((input.predictionStd.^2+respStd(k).^2 ))); % Add in crappy prediction noise here MRN! DONE
            end
        
            % generate internal representation:
            internalLike=nan;
            while ~isfinite(internalLike)|internalLike<0|internalLike>180 
            internalLike = normrnd(input.outcome(selSound), audLikeWid(selSound));
            end
          
            % generate posterior perception:
            gridTicks = 0:180;
            [postDist,~,~] = ...
                combinePriorAndAllLikes(input.prediction(k), sqrt(blkModelPredSigma(k).^2+input.predictionStd.^2) ,...
                internalLike, audLikeWid(selSound), hazard); % Add in crappy prediction noise here MRN! DONE.
            
            outcomeDist = sum(postDist,1);
            
            % add motor noise:
            motNoiseVar=normpdf(-50:50, 0, motorStd) ;
            outcomeDist=conv(outcomeDist, motNoiseVar, 'same');
            outcomeDist = outcomeDist./sum(outcomeDist);
            
            
            % MRN come back: this is only a posterior sampling version:
            if input.samplePosterior==true
                
                while ~isfinite(input.perception(k))| input.perception(k)>180| input.perception(k)<0
                    input.perception(k)=gridTicks(find(rand<=cumsum(outcomeDist), 1));
                end
                
            else
                
                while ~isfinite(input.perception(k))| input.perception(k)>180| input.perception(k)<0
                    %input.perception(k)=gridTicks(find(.5<=cumsum(outcomeDist), 1)); %posterior mode
                    %input.perception(k) = gridTicks(find(outcomeDist==max(outcomeDist), 1));
                    input.perception(k)= sum(gridTicks.*outcomeDist);
                    % posterior mean
                end
                
            end 
        end
    end
end

% get log likelihood of prediction:
auxPredLLK = log(normpdf(input.prediction,respMu,respStd)) - ...
    log(normcdf(180,respMu,respStd)-normcdf(0,respMu,respStd));
auxPredLLK(auxPredLLK == -Inf) = -100;
auxPredLLK(auxPredLLK < -100) = -100;
predBlkLogLike = nansum(auxPredLLK);
                  
    
% Now let us calculate the posterior distribution after the
% model has access to the noisy sensory stimulus. If the
% internal representation distr. is very different from the
% predictive distribution, then the prior is discarded.

% You only need to calculate this for wager trials
% (fixated)


% Internal representation means
% p(internal response|data)
% on each trial the unreliable sensory information should produce a
% likelihood distribution (with a mean drawn from the likelihood distribution)
% and a variance equal to that of the likelihood.


logPerceptLike=nan(length(input.prediction), 1);
CPP=nan(length(input.prediction), 1);
for k = 1:length(input.prediction)
    selSound=input.trialNum==k & input.probeTrial;
      
    if input.subjectiveFlag==true;  %we use the subject prediction instead of the model mean
        [posteriorDist, gridTicks, trial_CPP]=combinePriorAndAllLikes(input.prediction(k), ...
        sqrt(blkModelPredSigma(k).^2 + input.predictionStd.^2), input.outcome(selSound), audLikeWid(selSound), hazard); % Add in crappy prediction noise here MRN!
    else
     %   keyboard
        [posteriorDist, gridTicks, trial_CPP]=combinePriorAndAllLikes(respMu(k), ...
        sqrt(blkModelPredSigma(k).^2 + input.predictionStd.^2), input.outcome(selSound), audLikeWid(selSound), hazard); % Add in crappy prediction noise here MRN!
    end
    
    
    CPP(k)=trial_CPP;
    if motorStd>0
        % add motor noise:
        motNoiseVar=normpdf(-50:50, 0, motorStd) ;
        postSound=nanmean(posteriorDist, 2);
        perceptReportProb=conv(postSound, motNoiseVar, 'same');
    else
        perceptReportProb=postSound;
    end
    perceptReportProb=perceptReportProb./(sum(perceptReportProb));
    logPerceptLike(k)=log(perceptReportProb(gridTicks==round(input.perception(k))));
end

logPerceptLike(logPerceptLike == -Inf) = -100;
logPerceptLike(logPerceptLike < -100) = -100;
percBlkLogLike=nansum(logPerceptLike);

%negLLik = -1*( percBlkLogLike +  predBlkLogLike);

% DEBUG -- we don't really care about negLL of prediction for now: not
% fitting hazard. If you fit hazard then use the above equation
negLLik = -1*( percBlkLogLike);

if nargout>1
    input.trialOutcome=input.outcome(input.probeTrial)';
    input.totUnc=sqrt(blkModelPredSigma.^2 + input.predictionStd.^2); % MRN -- questionable... could add in crappy prediction noise... or not. 
    input.CPP=CPP;
end


